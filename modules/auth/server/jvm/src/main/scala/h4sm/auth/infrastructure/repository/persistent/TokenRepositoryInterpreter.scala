package h4sm.auth
package infrastructure.repository.persistent

import cats.data.OptionT
import cats.syntax.all._
import cats.effect.Bracket
import doobie._
import doobie.implicits._
import domain.tokens.{BaseToken, TokenRepositoryAlgebra}
import h4sm.auth.db.sql.tokens

class TokenRepositoryInterpreter[M[_]: Bracket[?[_], Throwable]](xa: Transactor[M])
    extends TokenRepositoryAlgebra[M] {
  def insert(a: BaseToken): M[Unit] = tokens.insert(a).run.as(()).transact(xa)

  // In this case, the id is not generated by the database.
  def insertGetId(a: BaseToken): OptionT[M, SecureRandomId] =
    OptionT.liftF(insert(a).as(a.secureId))

  def delete(i: SecureRandomId): M[Unit] = tokens.delete(i).run.as(()).transact(xa)

  def update(id: SecureRandomId, u: BaseToken): M[Unit] =
    tokens.update(id, u).run.as(()).transact(xa)

  def updateUnique(u: BaseToken): M[Unit] = update(u.secureId, u)

  def select: M[List[(BaseToken, SecureRandomId, Unit)]] =
    tokens.select.map(tok => (tok, tok.secureId, ())).to[List].transact(xa)

  def byId(id: SecureRandomId): OptionT[M, (BaseToken, SecureRandomId, Unit)] =
    OptionT(tokens.byId(id).map(tok => (tok, tok.secureId, ())).option.transact(xa))
}
